---
title: AMQP协议
categories:
  - 开发
  - 中间件
  - 消息队列
tags:
  - 消息队列
date: 2020-10-18 19:04:32
---


# 解决了什么问题？

## 如何降低发送者和接收者的耦合度？
    
* 发送者与接受者没有直接关系，发送者只与中转服务交互，中转服务通过交换机以不同的策略转发消息到接受者所定义的消息队列


## 如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。

* 消息队列与交换机通过路由规则绑定
* 用户可以控制消息队列和交换器的绑定规则，而不是依赖中间件自身的代码

## 权限控制？

虚拟主机(Virtual Hosts)

虚拟主机是服务器内的数据分区, 它为在共享基础设施上的管理带来了方便．
一个虚拟主机包括其命名空间，一组交换器，消息队列以及所有相关对象. 每个连接必须关联一个单个虚拟主机.
在认证后，客户端可在Connection.Open方法中选择虚拟主机. 这意味着，服务器上的认证方案可在此服务器上的所有虚拟主机上共享. 然而，对于每个虚拟主机来说，也可以独特的认证方案. 对于每个虚拟主机需要不同的身份验证方案的管理员应该使用单独的服务器。
连接中的所有通道都在同一个虚拟主机上工作.在同一个连接中，没有与不同虚拟主机通信的方式， 也没有在不断开连接重新开始的情况下，切换到其它虚拟主机的可能性.

## 消费者如何通过自身的能力，对消息做流控？

qos

## 如何做到可扩展，甚至将这个通信模块发到cluster上？

AMQP协议是一个二进制协议，具有一些现代特性：多通道（multi\-channel），可协商（negotiated），异步、安全、便携、语言中立、高效的。其协议主要分成两层：

![](https://pic4.zhimg.com/v2-631190d8c82a28c9e45e2a73ac59257b_b.jpg)

![](https://pic4.zhimg.com/80/v2-631190d8c82a28c9e45e2a73ac59257b_720w.jpg)

**功能层（Functional Layer）：**定义了一系列的命令

**传输层（Transport Layer）：**携带了从应用 → 服务端的方法，用于处理多路复用、分帧、编码、心跳、data\-representation、错误处理。

这样分层之后，可以把传输层替换为其它传输协议，而不需要修改功能层。同样，也可以使用同样的传输层，基于此实现不同的上层协议。可能RabbitMQ也是因为类似的原因，能够比较容易的支持MQTT、STOMP等协议的吧。


## 如何让Priority高的接收者先接到数据？

消费者优先级允许你确保高优先级消费者活动（非阻塞）的时候接收消息，低优先消费者只有在高优先级消费者阻塞的时候接收消息。

通常，连接到队列上的活动消费者以循环的方式从队列接收消息。当消费者使用优先级，如果多个活动消费者存在，且具有相同的优先级，则消息轮流传递。

设置x-priority参数给basic.consume方法，值是一个整数值。未指定值的消费者默认是0，数字越大优先级越高，可以使用正数和负数。

## 信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据是以什么方式丢失？

* 服务端收到消息，交换器（大部分情况）把消息路由到若干个该服务器上的消息队列中。如果这个消息找不到路由，则会丢弃或者退回给生产者（生产者可自行决定）。

* 消息到达消息队列。消息队列会立即尝试通过AMQP将其传递给消费者。 如果做不到，消息队列将消息存储（按生产者的要求存储在内存中或磁盘上），并等待消费者准备就绪。 如果没有消费者，则消息队列可以通过AMQP将消息返回给生产者（同样，如果生产者要求这样做）。

* 当消息队列可以将消息传递给消费者时，它将消息从其内部缓冲区中删除。 可以立即删除，也可以在使用者确认其已成功处理消息之后删除(ack)。 由消费者选择“确认”消息的方式和时间。消费者也可以拒绝消息（否定确认）。

* **持久化消息队列**：由很多消费者共享。当消费者都退出后，队列依然存在，并会继续收集消息。
* **临时消息队列：**临时消息队列对于消费者是私有和绑定的。当消费者断开连接，则消息队列被删除。


## 如何做到Load Balance？有效均衡接收者的负载？

* AMQP实现了Topic订阅的分发模型。这可以让订阅在合作的订阅者间进行负载均衡


## 如何保证接收者接收到了完整，正确的数据？

### 分帧方式

客户端连接时，和服务端协商可接受的配置。当两个节点达成一致后，连接才能继续使用。通过协商，可以让我们断言假设和前提条件。主要协商这几方面的信息

*   实现的协议和版本。服务端可能会在同一端口提供多种协议的支持
*   加密参数和验证
*   最大帧尺寸、Channel的数量、某些操作的限制。

如果协商达成一致，双方会根据协商预分配缓冲区避免死锁。传入的帧如果满足协商条件，则认为其实安全的。如果超过了，那么另一方必须断开连接。

### 帧细节

帧头包括：帧类型、通道、尺寸。帧尾包含错误检测信息。

![](https://pic1.zhimg.com/v2-22dc06024428c024d7c645726fb6f08c_b.png)

![](https://pic1.zhimg.com/80/v2-22dc06024428c024d7c645726fb6f08c_720w.png)

处理一个帧的步骤：

1.  读帧头，检查帧类型和Channel
2.  根据帧类型，读取payload并处理
3.  读帧尾校验

### 消费者ack机制


# 存在什么问题？




# 参考资料

* [AMQP协议学习](https://zhuanlan.zhihu.com/p/147675691)

* [AMQP 0-9-1 Protocol Specification](https://www.rabbitmq.com/protocol.html)

* [AMQP 0.9.1 完整的中文翻译](http://www.blogjava.net/qbna350816/archive/2016/08/12/431554.html)

* [AMQP 0.9.1 规范](https://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf)

* [RabbitMQ 对于 AMQP 0.9.1 的勘误](https://www.rabbitmq.com/amqp-0-9-1-errata.html)

* [RabbitMQ 对与 AMQP 0.9.1 的扩展](https://www.rabbitmq.com/extensions.html)

* [AMQP 1.0 最终版](https://www.amqp.org/specification/1.0/amqp-org-download)